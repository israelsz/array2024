# Usar cbind para unir las columnas de manera correcta
df_dna_final <- data.frame(Taxon = nombres_taxones, as.data.frame(matriz_dna), stringsAsFactors = FALSE)
# Comprobar las dimensiones del nuevo data.frame
dim(df_dna_final)
# Ver las primeras filas del nuevo data.frame
head(df_dna_final)
View(df_dna_final)
dim(df_dna_final)
# Obtener los nombres de los taxones
nombres_taxones <- rownames(datos_dna)
# Convertir las secuencias a una matriz (manteniendo el formato DNAbin)
matriz_dna <- as.matrix(datos_dna)
# Comprobar las dimensiones de la matriz de secuencias
dim(matriz_dna)
# Crear un data.frame combinando los nombres de los taxones y las secuencias
df_dna_final <- data.frame(Taxon = nombres_taxones, matriz_dna, stringsAsFactors = FALSE)
# Comprobar las dimensiones del nuevo data.frame
dim(df_dna_final)
# Ver las primeras filas del nuevo data.frame
head(df_dna_final)
################################################################################
# Obtener los nombres de los taxones
nombres_taxones <- rownames(datos_dna)
# Convertir las secuencias a una matriz (manteniendo el formato DNAbin)
matriz_dna <- as.matrix(datos_dna)
# Crear un data.frame combinando los nombres de los taxones y las secuencias
# Usar cbind para unir las columnas de manera correcta
df_dna_final <- data.frame(Taxon = nombres_taxones, as.data.frame(matriz_dna), stringsAsFactors = FALSE)
# Comprobar las dimensiones del nuevo data.frame
dim(df_dna_final)
# Ver las primeras filas del nuevo data.frame
head(df_dna_final)
dim(df_dna_final)
# Obtener los nombres de los taxones
nombres_taxones <- rownames(datos_dna)
# Convertir las secuencias a una matriz (manteniendo el formato DNAbin)
matriz_dna <- as.matrix(datos_dna)
# Utilizar cbind para combinar los nombres de taxones y la matriz de secuencias
df_dna_final <- cbind(Taxon = nombres_taxones, matriz_dna)
# Obtener los nombres de los taxones
nombres_taxones <- rownames(datos_dna)
# Convertir las secuencias a una matriz manteniendo el formato DNAbin
matriz_dna <- as.matrix(datos_dna)
# Convertir la matriz de DNAbin a un data.frame
df_matriz_dna <- as.data.frame(matriz_dna)
# Crear un data.frame combinando los nombres de los taxones y las secuencias
df_dna_final <- data.frame(Taxon = nombres_taxones, df_matriz_dna, stringsAsFactors = FALSE)
# Verificar las dimensiones del nuevo data.frame
dim(df_dna_final)
# Ver las primeras filas del nuevo data.frame
head(df_dna_final)
View(df_dna_final)
matriz_dna_phydat <- as.phyDat(data)
matriz_dna_phydat <- as.phyDat.AAbin(data)
install.packages("phangorn",dependencies = TRUE)
datos_dna <- read.dna("C:\\Users\\Israel\\Documents\\Codes\\Taller de investigación\\array-code\\array-code-definitivo\\datasets\\primates_14.phylip",format = "interleaved")
# Convert the multiple sequence alignment result to a phyDat object for downstream analyses in phangorn
phyDat_msa_primate_sample = as.phyDat(datos_dna)
library("phangorn")
phyDat_msa_primate_sample = as.phyDat(datos_dna)
View(phyDat_msa_primate_sample)
phyDat_msa_primate_sample[["Mouse"]]
datos_dna <- read.dna("C:\\Users\\Israel\\Documents\\Codes\\Taller de investigación\\array-code\\array-code-definitivo\\datasets\\primates_14.phylip")
# Convert the multiple sequence alignment result to a phyDat object for downstream analyses in phangorn
phyDat_msa_primate_sample = as.phyDat(datos_dna)
View(phyDat_msa_primate_sample)
D_hamming = dist.hamming(phyDat_msa_primate_sample)
# Compute the Neighbor Joining tree
nj_tree = nj(D_hamming) #Aplica nj
nj_tree$edge.length[which(nj_tree$edge.length<0)]= 1 #Reemplaza los edges donde sea menor a cero por 1
nj_tree = midpoint(multi2di(nj_tree)) # Binariza los arboles
g_NJ  = plot_tree(nj_tree, "Neighbor Joining (NJ)", 0.3)
library("ggtree")       # For phylogenetic tree visualization
install.packages("ggtree",dependencies = TRUE)
install.packages("ggtree",dependencies = TRUE)
source("http://bioconductor.org/biocLite.R")
source("https://bioconductor.org/biocLite.R")
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("ggtree")
# Create plots for the NJ tree
# Specify titles for each plot
g_NJ  = plot_tree(nj_tree, "Neighbor Joining (NJ)", 0.3)
library("ggtree")       # For phylogenetic tree visualization
library("ggplot2")      # For plotting
library("gridExtra")    # For organizing plots in a grid
g_NJ  = plot_tree(nj_tree, "Neighbor Joining (NJ)", 0.3)
# Function to plot trees
plot_tree = function(tree_plot, title_plot, max_x) {
g = ggtree(tree_plot, color = "#00A499", size = 1)
# Customize the appearance of the plot and tip labels
g = g + geom_tiplab(size = 4, color = "black", align = TRUE) +
geom_nodepoint(size = 3, color = "#c7254e") +
labs(title = title_plot, size = 6) +
xlim(0, max_x) +
theme(
# Remove axis lines and text
axis.line = element_blank(),
axis.text = element_blank(),
# Remove all grids
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
# Adjust margins and legend position
plot.margin = margin(t = 0, r = -5, b = 0, l = 0, unit = "pt"),
legend.position = 'top'
)
# Create plots for the NJ tree
# Specify titles for each plot
g_NJ  = plot_tree(nj_tree, "Neighbor Joining (NJ)", 0.3)
)
# Function to plot trees
plot_tree = function(tree_plot, title_plot, max_x) {
g = ggtree(tree_plot, color = "#00A499", size = 1)
# Customize the appearance of the plot and tip labels
g = g + geom_tiplab(size = 4, color = "black", align = TRUE) +
geom_nodepoint(size = 3, color = "#c7254e") +
labs(title = title_plot, size = 6) +
xlim(0, max_x) +
theme(
# Remove axis lines and text
axis.line = element_blank(),
axis.text = element_blank(),
# Remove all grids
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
# Adjust margins and legend position
plot.margin = margin(t = 0, r = -5, b = 0, l = 0, unit = "pt"),
legend.position = 'top'
)
# Add labels for branch lengths with a smaller font size
g = g + geom_text(aes(x = branch, label = round(branch, 2)), size = 3, color = "black", vjust = -0.5, hjust = 0)
return(g)
}
# Create plots for the NJ tree
# Specify titles for each plot
g_NJ  = plot_tree(nj_tree, "Neighbor Joining (NJ)", 0.3)
View(g_NJ)
g_NJ  = plot_tree(nj_tree, "Neighbor Joining (NJ)", 0.3)
View(g_NJ)
library("gridExtra")    # For organizing plots in a grid
g_NJ  = plot_tree(nj_tree, "Neighbor Joining (NJ)", 0.3)
# Organize the two plots in a one-row, two-column grid
grid.arrange(g_NJ, nrow = 1, ncol = 1)
View(nj_tree)
library("ape")
library("phangorn")
library("ggtree")       # For phylogenetic tree visualization
library("ggplot2")      # For plotting
library("gridExtra")    # For organizing plots in a grid
datos_dna <- read.dna("C:\\Users\\Israel\\Documents\\Codes\\Taller de investigación\\array-code\\array-code-definitivo\\datasets\\primates_14.phylip")
# Obtener los nombres de los taxones
nombres_taxones <- rownames(datos_dna)
# Convertir las secuencias a una matriz (manteniendo el formato DNAbin)
matriz_dna <- as.matrix(datos_dna)
# Comprobar las dimensiones de la matriz de secuencias
dim(matriz_dna)
datos_dna <- read.dna("C:\\Users\\Israel\\Documents\\Codes\\Taller de investigación\\array-code\\array-code-definitivo\\datasets\\primates_14.phylip")
# Convert the multiple sequence alignment result to a phyDat object for downstream analyses in phangorn
phyDat_msa_primate_sample = as.phyDat(datos_dna)
# Distance Calculation
# Calculate the Hamming distance matrix for the given aligned sequences
# This serves as a measure of pairwise sequence dissimilarity for tree construction
D_hamming = dist.hamming(phyDat_msa_primate_sample)
# Compute the Neighbor Joining tree
nj_tree = nj(D_hamming) #Aplica nj
nj_tree$edge.length[which(nj_tree$edge.length<0)]= 1 #Reemplaza los edges donde sea menor a cero por 1
nj_tree = midpoint(multi2di(nj_tree)) # Binariza los arboles
# Function to plot trees
plot_tree = function(tree_plot, title_plot, max_x) {
g = ggtree(tree_plot, color = "#00A499", size = 1)
# Customize the appearance of the plot and tip labels
g = g + geom_tiplab(size = 4, color = "black", align = TRUE) +
geom_nodepoint(size = 3, color = "#c7254e") +
labs(title = title_plot, size = 6) +
xlim(0, max_x) +
theme(
# Remove axis lines and text
axis.line = element_blank(),
axis.text = element_blank(),
# Remove all grids
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
# Adjust margins and legend position
plot.margin = margin(t = 0, r = -5, b = 0, l = 0, unit = "pt"),
legend.position = 'top'
)
# Add labels for branch lengths with a smaller font size
g = g + geom_text(aes(x = branch, label = round(branch, 2)), size = 3, color = "black", vjust = -0.5, hjust = 0)
return(g)
}
# Create plots for the NJ tree
# Specify titles for each plot
g_NJ  = plot_tree(nj_tree, "Neighbor Joining (NJ)", 0.3)
# Organize the two plots in a one-row, two-column grid
grid.arrange(g_NJ, nrow = 1, ncol = 1)
nj_tree
arboles = rNNI(nj_tree, moves = 1)
g_nni  = plot_tree(nj_tree, "Arbol post NNI", 0.3)
grid.arrange(g_nni, nrow = 1, ncol = 1)
arboles = rNNI(nj_tree, moves = 1)
g_nni  = plot_tree(arboles, "Arbol post NNI", 0.3)
grid.arrange(g_nni, nrow = 1, ncol = 1)
View(g_nni)
View(g_NJ)
View(arboles)
arboles = rNNI(nj_tree, moves = 1)
g_nni  = plot_tree(arboles, "Arbol post NNI", 0.4)
grid.arrange(g_nni, nrow = 1, ncol = 1)
# Create plots for the NJ tree
# Specify titles for each plot
g_NJ  = plot_tree(nj_tree, "Neighbor Joining (NJ)", 0.4)
g_nni  = plot_tree(arboles, "Arbol post NNI", 0.4)
grid.arrange(g,NJ,g_nni, nrow = 2, ncol = 1)
grid.arrange(g_NJ,g_nni, nrow = 2, ncol = 1)
grid.arrange(g_NJ,g_nni, nrow = 1, ncol = 2)
is.binary.tree(nj_tree)
is.binary(nj_tree)
is.binary(arboles)
# Prueba mas de un arbol al mismo tiempo
multiarboles = rNNI(nj_tree, moves = 1, n = 10)
View(multiarboles)
multiarboles
multiarboles[1]
multiarboles[[1]]
g1 = plot_tree(multiarboles[[1]], "arbol1", 0.4)
g2 = plot_tree(multiarboles[[2]], "arbol2", 0.4)
g3 = plot_tree(multiarboles[[3]], "arbol3", 0.4)
g4 = plot_tree(multiarboles[[4]], "arbol4", 0.4)
g5 = plot_tree(multiarboles[[5]], "arbol5", 0.4)
g6 = plot_tree(multiarboles[[6]], "arbol6", 0.4)
g7 = plot_tree(multiarboles[[7]], "arbol7", 0.4)
g8 = plot_tree(multiarboles[[8]], "arbol8", 0.4)
g9 = plot_tree(multiarboles[[9]], "arbol9", 0.4)
g10 = plot_tree(multiarboles[[10]], "arbol10", 0.4)
grid.arrange(g1,g2,g3,g4,g5,g6,g7,g8,g9,g10,nrow = 2, ncol = 5)
is.binary(multiarboles[[1]])
is.binary(multiarboles[[4]])
is.binary(multiarboles[[5]])
is.binary(multiarboles[[6]])
is.binary(multiarboles[[7]])
is.binary(multiarboles[[8]])
is.binary(multiarboles[[9]])
is.binary(multiarboles[[10]])
# Saving to Newick
write.tree(multiarboles, file="multiarboles.nwk")
View(multiarboles)
View(multiarboles)
for (i in seq_along(multiarboles)) {
# Verifica si el árbol en la posición i no es binario
if (!is.binary(multiarboles[[i]])) {
# Si no es binario, lo reemplaza con la versión binarizada
print(i)
print("No es binario, arreglando")
multiarboles[[i]] = multi2di(multiarboles[[i]])
}
}
seq_along(multiarboles)
# Compute the average tree by suppressing any console messages
average_tree = averageTree(multiarboles, method = "path.difference",quiet=T)
install.packages("phytools",dependencies = TRUE)
install.packages("phytools", dependencies = TRUE)
# Compute the average tree by suppressing any console messages
average_tree = averageTree(multiarboles, method = "path.difference",quiet=T)
library("phytools")
# Compute the average tree by suppressing any console messages
average_tree = averageTree(multiarboles, method = "path.difference",quiet=T)
View(multiarboles)
print(is.binary(average_tree))
average_tree = midpoint(average_tree)
library("ape")
library("phangorn")
library("ggtree")       # For phylogenetic tree visualization
library("ggplot2")      # For plotting
library("gridExtra")    # For organizing plots in a grid
library("phytools")
average_tree = midpoint(average_tree)
# Compute the average tree by suppressing any console messages
average_tree = averageTree(multiarboles, method = "path.difference",quiet=T)
print(is.binary(average_tree))
ggtree(average_tree)
View(average_tree)
average_tree = midpoint(average_tree)
View(average_tree)
View(nj_tree)
average_tree[["node.label"]]
nj_tree[["tip.label"]]
nj_tree[["edge.length"]]
# Compute the average tree by suppressing any console messages
average_tree = averageTree(multiarboles, method = "path.difference",quiet=T)
average_tree[["node.label"]]
average_tree[["node.label"]][[1]]
average_tree[["node.label"]][[5]]
average_tree[["node.label"]][[6]]
average_tree[["node.label"]][[7]]
# Arbol Medioide consenso
# Initialize an empty matrix for RF distances with dimensions 100x100
RF_distance_matrix = matrix(0, 100, 100)
# Calculate Robinson-Foulds (RF) distances between all pairs of trees in 'arboles_bm'
for (a in 1:100) {
for (b in 1:100) {
# Calculate the RF distance between tree 'a' and tree 'b' and store it in the matrix
RF_distance_matrix[a, b] = RF.dist(multiarboles[[a]], multiarboles[[b]], normalize = TRUE)
}
}
# Arbol Medioide consenso
# Initialize an empty matrix for RF distances with dimensions 100x100
RF_distance_matrix = matrix(0, 100, 100)
# Calculate Robinson-Foulds (RF) distances between all pairs of trees in 'arboles_bm'
for (a in 1:100) {
for (b in 1:100) {
# Calculate the RF distance between tree 'a' and tree 'b' and store it in the matrix
RF_distance_matrix[a, b] = RF.dist(multiarboles[[a]], multiarboles[[b]], normalize = TRUE)
}
}
View(multiarboles)
# Arbol Medioide consenso
# Initialize an empty matrix for RF distances with dimensions 100x100
RF_distance_matrix = matrix(0, 10, 10)
# Calculate Robinson-Foulds (RF) distances between all pairs of trees in 'arboles_bm'
for (a in 1:10) {
for (b in 1:10) {
# Calculate the RF distance between tree 'a' and tree 'b' and store it in the matrix
RF_distance_matrix[a, b] = RF.dist(multiarboles[[a]], multiarboles[[b]], normalize = TRUE)
}
}
# Find the index of the tree that minimizes the average RF distance
idx_med = which.min(colMeans(RF_distance_matrix))
# Medoid: Select the tree that corresponds to the medoid index
medoid_tree = multiarboles[[idx_med]]
medoid_tree = midpoint(medoid_tree)
print(is.binary.tree(medoid_tree))
ggtree(medoid_tree)
g_consenso  = plot_tree(medoid_tree, "Arbol Consenso", 0.4)
grid.arrange(g_consenso nrow = 1, ncol = 1)
g_consenso  = plot_tree(medoid_tree, "Arbol Consenso", 0.4)
grid.arrange(g_consenso, nrow = 1, ncol = 1)
medoid_tree$edge.length[which(medoid_tree$edge.length<=0)]= 1 #Reemplaza los edges donde sea menor a cero por 1
medoid_tree = midpoint(medoid_tree)
print(is.binary.tree(medoid_tree))
g_consenso  = plot_tree(medoid_tree, "Arbol Consenso", 0.4)
grid.arrange(g_consenso, nrow = 1, ncol = 1)
View(medoid_tree)
medoid_tree[["edge.length"]]
red_filo = read.tree("./array-code-definitivo/phylonet.nwk")
View(red_filo)
red_filo[["node.label"]]
red_filo[["tip.label"]]
red_filo[["edge.length"]]
red_filo[["edge"]]
# Graficar la red filogenética
plot(red_filo, type = "unrooted", edge.width = 2, no.margin = TRUE)
install.packages("igraph",dependencies = TRUE)
# Convertir la red filogenética a un objeto igraph (si es necesario)
red_igraph = as.igraph(red_filo)
library(igraph)
# Convertir la red filogenética a un objeto igraph (si es necesario)
red_igraph = as.igraph(red_filo)
# Obtener las etiquetas de los nodos
etiquetas <- red_filo$tip.label
# Verificar si hay etiquetas duplicadas
duplicadas <- etiquetas[duplicated(etiquetas)]
# Imprimir las etiquetas duplicadas (si las hay)
if (length(duplicadas) > 0) {
print(paste("Etiquetas duplicadas encontradas:", duplicadas))
} else {
print("No hay etiquetas duplicadas")
}
# Graficar la red filogenética
plot(red_filo, type = "unrooted", edge.width = 2, no.margin = TRUE)
# Graficar la red filogenética
plot(red_filo, type = "unrooted", edge.width = 2, no.margin = TRUE)
View(red_filo)
red_filo$edge.length[which(red_filo$edge.length<0)]= 1 #Reemplaza los edges donde sea menor a cero por 1
red_filo$edge.length[which(red_filo$edge.length==NaN)]= 1 #Reemplaza los edges donde sea menor a cero por 1
View(red_filo)
View(red_filo)
red_filo[["edge.length"]]
red_filo[["tip.label"]]
red_filo[["node.label"]]
View(nj_tree)
red_filo$edge.length[is.na(red_filo$edge.length)] = 1
# Graficar la red filogenética
plot(red_filo, type = "unrooted", edge.width = 2, no.margin = TRUE)
# Graficar la red filogenética
plot(red_filo, type = "unrooted", edge.width = 2, no.margin = TRUE)
# Graficar la red filogenética
plot(red_filo, type = "rooted", edge.width = 2, no.margin = TRUE)
# Graficar la red filogenética
plot(red_filo, type = "radial", edge.width = 2, no.margin = TRUE)
# Graficar la red filogenética
plot(red_filo, type = "phylogram", edge.width = 2, no.margin = TRUE)
# Graficar la red filogenética
plot(red_filo, type = "fan", edge.width = 2, no.margin = TRUE)
# Graficar la red filogenética
plot(red_filo, type = "tidy", edge.width = 2, no.margin = TRUE)
red_up= as.networx(red_filo)
library("ape")
library("phangorn")
library("ggtree")       # For phylogenetic tree visualization
library("ggplot2")      # For plotting
library("gridExtra")    # For organizing plots in a grid
library("phytools")
red_filo = read.tree("./array-code-definitivo/phylonet.nwk")
View(red_filo)
red_filo$edge.length[is.na(red_filo$edge.length)] = 1
red_up= as.networx(red_filo)
View(red_up)
red_up[["splits"]]
# Graficar la red filogenética
plot(red_up, type = "fan", edge.width = 2, no.margin = TRUE)
# Graficar la red filogenética
plot(red_up, type = "2D", edge.width = 2, no.margin = TRUE)
# Graficar la red filogenética
plot(red_up, type = "3D", edge.width = 2, no.margin = TRUE)
# Graficar la red filogenética
plot(red_up, type = "equal angle", edge.width = 2, no.margin = TRUE)
# Graficar la red filogenética
plot(red_up, type = "2D", edge.width = 2, no.margin = TRUE)
View(multiarboles)
# Crear red filo directo en R
red_r = consensusNet(multiarboles, .3)
View(red_r)
plot(red_r, type = "equal angle", show.edge.label=TRUE)
plot(red_r, type = "3D", show.edge.label=TRUE)
plot(red_r, type = "2D", show.edge.label=TRUE)
red_igraph <- as.igraph(red_r)
# Graficar la red usando igraph
plot(red_igraph)
plot(red_r, type = "2D", show.edge.label=TRUE)
View(red_r)
red_r[["splits"]]
plot.networx(red_r, type = "2D", show.edge.label=TRUE)
# Saving to Newick
write.tree(red_r, file="red_r.nwk")
# Crear red filo directo en R
red_r = consensusNet(multiarboles, .8)
plot(red_r, type = "2D", show.edge.label=TRUE)
# Saving to Newick
write.tree(red_r, file="red_r.nwk")
View(red_filo)
# Graficar la red filogenética
plot(red_filo, type = "2D", edge.width = 2, no.margin = TRUE)
# Graficar la red filogenética
plot(red_filo, type = "cladogram", edge.width = 2, no.margin = TRUE)
is.binary(red_filo)
red_filo_binaria = multi2di(red_filo)
# Graficar la red filogenética
plot(red_filo_binaria, type = "cladogram", edge.width = 2, no.margin = TRUE)
# Graficar la red filogenética
plot(red_filo_binaria, type = "phylogram", edge.width = 2, no.margin = TRUE)
# Graficar la red filogenética
plot(red_filo, type = "phylogram", edge.width = 2, no.margin = TRUE)
red_filo_binaria = midpoint(multi2di(red_filo))
# Graficar la red filogenética
plot(red_filo_binaria, type = "phylogram", edge.width = 2, no.margin = TRUE)
# Saving to Newick
write.tree(red_filo_binaria, file="red_filo_binaria.nwk")
matriz_dna <- as.matrix(data)
library("ape")
library("phangorn")
library("ggtree")       # For phylogenetic tree visualization
library("ggplot2")      # For plotting
library("gridExtra")    # For organizing plots in a grid
library("phytools")
datos_dna <- read.dna("C:\\Users\\Israel\\Documents\\Codes\\Taller de investigación\\array-code\\array-code-definitivo\\datasets\\primates_14.phylip")
matriz_dna <- as.matrix(data)
# Obtener los nombres de los taxones
nombres_taxones <- rownames(data)
# Obtener los nombres de los taxones
nombres_taxones <- rownames(datos_dna)
# Convertir las secuencias a una matriz (manteniendo el formato DNAbin)
matriz_dna <- as.matrix(datos_dna)
# Crear un data.frame con los nombres de los taxones y las secuencias
df_dna <- data.frame(Taxon = nombres_taxones, matriz_dna, stringsAsFactors = FALSE)
# Convertir las secuencias a una matriz (manteniendo el formato DNAbin)
matriz_dna <- as.matrix(datos_dna)
matriz_dna
# Comprobar las dimensiones de la matriz de secuencias
dim(matriz_dna)
View(df_dna)
datos_dna
# Convertir el objeto DNAbin a una matriz
matriz_dna <- as.matrix(datos_dna)
# Obtener los nombres de los taxones (nombres de las filas de la matriz)
nombres_taxones <- rownames(matriz_dna)
nombres_taxones
matriz_dna
as.character(matriz_dna)
# Convertir la matriz DNAbin a una matriz de caracteres legibles
matriz_dna_caracter <- as.character(matriz_dna)
matriz_dna_caracter
# Crear un data.frame con los nombres de los taxones y las secuencias legibles
df_dna_caracter <- data.frame(Taxon = rownames(matriz_dna_caracter), matriz_dna_caracter, stringsAsFactors = FALSE)
View(df_dna_caracter)
dim(df_dna_caracter)
df_dna_caracter[[1]][[1]]
df_dna_caracter[[0]][[1]]
df_dna_caracter[[1]][[2]]
df_dna_caracter[[2]][[2]]
df_dna_caracter[[1]][[2]]
df_dna_caracter[[2]][[1]]
df_dna_caracter[[3]][[1]]
df_dna_caracter[[4]][[1]]
df_dna_caracter[[5][[1]]
df_dna_caracter[[5]][[1]]
df_dna_caracter[[12]][[1]]
df_dna_caracter[[12]][[2]]
# Crear un data.frame con los nombres de los taxones y las secuencias legibles
df_dna_caracter <- data.frame(species = rownames(matriz_dna_caracter), matriz_dna_caracter, stringsAsFactors = FALSE)
matriz_dna_caracter
View(matriz_dna_caracter)
write.FASTA(datos_dna,"primates_14.fasta")
